// Copyright (C) 1991-2015 Altera Corporation. All rights reserved.
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, the Altera Quartus Prime License Agreement,
// the Altera MegaCore Function License Agreement, or other 
// applicable license agreement, including, without limitation, 
// that your use is for the sole purpose of programming logic 
// devices manufactured by Altera and sold by Altera or its 
// authorized distributors.  Please refer to the applicable 
// agreement for further details.

// VENDOR "Altera"
// PROGRAM "Quartus Prime"
// VERSION "Version 15.1.0 Build 185 10/21/2015 SJ Lite Edition"

// DATE "01/19/2018 15:23:29"

// 
// Device: Altera 5CGXFC7C7F23C8 Package FBGA484
// 

// 
// This Verilog file should be used for ModelSim-Altera (Verilog) only
// 

`timescale 1 ps/ 1 ps

module pc (
	CLOCK,
	habilitaPC,
	entradaPC,
	saidaPC);
input 	CLOCK;
input 	habilitaPC;
input 	[7:0] entradaPC;
output 	[7:0] saidaPC;

wire gnd;
wire vcc;
wire unknown;

assign gnd = 1'b0;
assign vcc = 1'b1;
assign unknown = 1'bx;

tri1 devclrn;
tri1 devpor;
tri1 devoe;
wire \saidaPC[0]~output_o ;
wire \saidaPC[1]~output_o ;
wire \saidaPC[2]~output_o ;
wire \saidaPC[3]~output_o ;
wire \saidaPC[4]~output_o ;
wire \saidaPC[5]~output_o ;
wire \saidaPC[6]~output_o ;
wire \saidaPC[7]~output_o ;
wire \CLOCK~input_o ;
wire \habilitaPC~input_o ;
wire \entradaPC[0]~input_o ;
wire \entradaPC[1]~input_o ;
wire \next_instruction~1_combout ;
wire \cont~0_combout ;
wire \entradaPC[2]~input_o ;
wire \next_instruction~2_combout ;
wire \entradaPC[3]~input_o ;
wire \next_instruction~3_combout ;
wire \cont~2_combout ;
wire \entradaPC[4]~input_o ;
wire \cont~1_combout ;
wire \next_instruction~4_combout ;
wire \entradaPC[5]~input_o ;
wire \next_instruction~5_combout ;
wire \cont~4_combout ;
wire \entradaPC[6]~input_o ;
wire \cont~3_combout ;
wire \next_instruction~6_combout ;
wire \entradaPC[7]~input_o ;
wire \next_instruction~7_combout ;
wire \cont~5_combout ;
wire \cont~q ;
wire \next_instruction~0_combout ;
wire \saidaPC[0]~reg0_q ;
wire \saidaPC[1]~reg0_q ;
wire \saidaPC[2]~reg0_q ;
wire \saidaPC[3]~reg0_q ;
wire \saidaPC[4]~reg0_q ;
wire \saidaPC[5]~reg0_q ;
wire \saidaPC[6]~reg0_q ;
wire \saidaPC[7]~reg0_q ;
wire [7:0] last_instruction;


cyclonev_io_obuf \saidaPC[0]~output (
	.i(\saidaPC[0]~reg0_q ),
	.oe(vcc),
	.dynamicterminationcontrol(gnd),
	.seriesterminationcontrol(16'b0000000000000000),
	.parallelterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\saidaPC[0]~output_o ),
	.obar());
// synopsys translate_off
defparam \saidaPC[0]~output .bus_hold = "false";
defparam \saidaPC[0]~output .open_drain_output = "false";
defparam \saidaPC[0]~output .shift_series_termination_control = "false";
// synopsys translate_on

cyclonev_io_obuf \saidaPC[1]~output (
	.i(\saidaPC[1]~reg0_q ),
	.oe(vcc),
	.dynamicterminationcontrol(gnd),
	.seriesterminationcontrol(16'b0000000000000000),
	.parallelterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\saidaPC[1]~output_o ),
	.obar());
// synopsys translate_off
defparam \saidaPC[1]~output .bus_hold = "false";
defparam \saidaPC[1]~output .open_drain_output = "false";
defparam \saidaPC[1]~output .shift_series_termination_control = "false";
// synopsys translate_on

cyclonev_io_obuf \saidaPC[2]~output (
	.i(\saidaPC[2]~reg0_q ),
	.oe(vcc),
	.dynamicterminationcontrol(gnd),
	.seriesterminationcontrol(16'b0000000000000000),
	.parallelterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\saidaPC[2]~output_o ),
	.obar());
// synopsys translate_off
defparam \saidaPC[2]~output .bus_hold = "false";
defparam \saidaPC[2]~output .open_drain_output = "false";
defparam \saidaPC[2]~output .shift_series_termination_control = "false";
// synopsys translate_on

cyclonev_io_obuf \saidaPC[3]~output (
	.i(\saidaPC[3]~reg0_q ),
	.oe(vcc),
	.dynamicterminationcontrol(gnd),
	.seriesterminationcontrol(16'b0000000000000000),
	.parallelterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\saidaPC[3]~output_o ),
	.obar());
// synopsys translate_off
defparam \saidaPC[3]~output .bus_hold = "false";
defparam \saidaPC[3]~output .open_drain_output = "false";
defparam \saidaPC[3]~output .shift_series_termination_control = "false";
// synopsys translate_on

cyclonev_io_obuf \saidaPC[4]~output (
	.i(\saidaPC[4]~reg0_q ),
	.oe(vcc),
	.dynamicterminationcontrol(gnd),
	.seriesterminationcontrol(16'b0000000000000000),
	.parallelterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\saidaPC[4]~output_o ),
	.obar());
// synopsys translate_off
defparam \saidaPC[4]~output .bus_hold = "false";
defparam \saidaPC[4]~output .open_drain_output = "false";
defparam \saidaPC[4]~output .shift_series_termination_control = "false";
// synopsys translate_on

cyclonev_io_obuf \saidaPC[5]~output (
	.i(\saidaPC[5]~reg0_q ),
	.oe(vcc),
	.dynamicterminationcontrol(gnd),
	.seriesterminationcontrol(16'b0000000000000000),
	.parallelterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\saidaPC[5]~output_o ),
	.obar());
// synopsys translate_off
defparam \saidaPC[5]~output .bus_hold = "false";
defparam \saidaPC[5]~output .open_drain_output = "false";
defparam \saidaPC[5]~output .shift_series_termination_control = "false";
// synopsys translate_on

cyclonev_io_obuf \saidaPC[6]~output (
	.i(\saidaPC[6]~reg0_q ),
	.oe(vcc),
	.dynamicterminationcontrol(gnd),
	.seriesterminationcontrol(16'b0000000000000000),
	.parallelterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\saidaPC[6]~output_o ),
	.obar());
// synopsys translate_off
defparam \saidaPC[6]~output .bus_hold = "false";
defparam \saidaPC[6]~output .open_drain_output = "false";
defparam \saidaPC[6]~output .shift_series_termination_control = "false";
// synopsys translate_on

cyclonev_io_obuf \saidaPC[7]~output (
	.i(\saidaPC[7]~reg0_q ),
	.oe(vcc),
	.dynamicterminationcontrol(gnd),
	.seriesterminationcontrol(16'b0000000000000000),
	.parallelterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\saidaPC[7]~output_o ),
	.obar());
// synopsys translate_off
defparam \saidaPC[7]~output .bus_hold = "false";
defparam \saidaPC[7]~output .open_drain_output = "false";
defparam \saidaPC[7]~output .shift_series_termination_control = "false";
// synopsys translate_on

cyclonev_io_ibuf \CLOCK~input (
	.i(CLOCK),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\CLOCK~input_o ));
// synopsys translate_off
defparam \CLOCK~input .bus_hold = "false";
defparam \CLOCK~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_io_ibuf \habilitaPC~input (
	.i(habilitaPC),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\habilitaPC~input_o ));
// synopsys translate_off
defparam \habilitaPC~input .bus_hold = "false";
defparam \habilitaPC~input .simulate_z_as = "z";
// synopsys translate_on

dffeas \last_instruction[0] (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~0_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(last_instruction[0]),
	.prn(vcc));
// synopsys translate_off
defparam \last_instruction[0] .is_wysiwyg = "true";
defparam \last_instruction[0] .power_up = "low";
// synopsys translate_on

cyclonev_io_ibuf \entradaPC[0]~input (
	.i(entradaPC[0]),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\entradaPC[0]~input_o ));
// synopsys translate_off
defparam \entradaPC[0]~input .bus_hold = "false";
defparam \entradaPC[0]~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_io_ibuf \entradaPC[1]~input (
	.i(entradaPC[1]),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\entradaPC[1]~input_o ));
// synopsys translate_off
defparam \entradaPC[1]~input .bus_hold = "false";
defparam \entradaPC[1]~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_lcell_comb \next_instruction~1 (
// Equation(s):
// \next_instruction~1_combout  = ( \entradaPC[1]~input_o  & ( !last_instruction[1] $ (((!last_instruction[0] & (\entradaPC[0]~input_o  & \cont~q )) # (last_instruction[0] & ((\cont~q ) # (\entradaPC[0]~input_o ))))) ) ) # ( !\entradaPC[1]~input_o  & ( 
// !last_instruction[1] $ (((!last_instruction[0] & ((!\entradaPC[0]~input_o ) # (!\cont~q ))) # (last_instruction[0] & (!\entradaPC[0]~input_o  & !\cont~q )))) ) )

	.dataa(!last_instruction[0]),
	.datab(!\entradaPC[0]~input_o ),
	.datac(!\cont~q ),
	.datad(!last_instruction[1]),
	.datae(!\entradaPC[1]~input_o ),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\next_instruction~1_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \next_instruction~1 .extended_lut = "off";
defparam \next_instruction~1 .lut_mask = 64'h17E8E81717E8E817;
defparam \next_instruction~1 .shared_arith = "off";
// synopsys translate_on

dffeas \last_instruction[1] (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~1_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(last_instruction[1]),
	.prn(vcc));
// synopsys translate_off
defparam \last_instruction[1] .is_wysiwyg = "true";
defparam \last_instruction[1] .power_up = "low";
// synopsys translate_on

cyclonev_lcell_comb \cont~0 (
// Equation(s):
// \cont~0_combout  = ( \entradaPC[1]~input_o  & ( ((!last_instruction[0] & (\entradaPC[0]~input_o  & \cont~q )) # (last_instruction[0] & ((\cont~q ) # (\entradaPC[0]~input_o )))) # (last_instruction[1]) ) ) # ( !\entradaPC[1]~input_o  & ( 
// (last_instruction[1] & ((!last_instruction[0] & (\entradaPC[0]~input_o  & \cont~q )) # (last_instruction[0] & ((\cont~q ) # (\entradaPC[0]~input_o ))))) ) )

	.dataa(!last_instruction[0]),
	.datab(!\entradaPC[0]~input_o ),
	.datac(!\cont~q ),
	.datad(!last_instruction[1]),
	.datae(!\entradaPC[1]~input_o ),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\cont~0_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \cont~0 .extended_lut = "off";
defparam \cont~0 .lut_mask = 64'h001717FF001717FF;
defparam \cont~0 .shared_arith = "off";
// synopsys translate_on

cyclonev_io_ibuf \entradaPC[2]~input (
	.i(entradaPC[2]),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\entradaPC[2]~input_o ));
// synopsys translate_off
defparam \entradaPC[2]~input .bus_hold = "false";
defparam \entradaPC[2]~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_lcell_comb \next_instruction~2 (
// Equation(s):
// \next_instruction~2_combout  = !\cont~0_combout  $ (!last_instruction[2] $ (\entradaPC[2]~input_o ))

	.dataa(!\cont~0_combout ),
	.datab(!last_instruction[2]),
	.datac(!\entradaPC[2]~input_o ),
	.datad(gnd),
	.datae(gnd),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\next_instruction~2_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \next_instruction~2 .extended_lut = "off";
defparam \next_instruction~2 .lut_mask = 64'h6969696969696969;
defparam \next_instruction~2 .shared_arith = "off";
// synopsys translate_on

dffeas \last_instruction[2] (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~2_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(last_instruction[2]),
	.prn(vcc));
// synopsys translate_off
defparam \last_instruction[2] .is_wysiwyg = "true";
defparam \last_instruction[2] .power_up = "low";
// synopsys translate_on

cyclonev_io_ibuf \entradaPC[3]~input (
	.i(entradaPC[3]),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\entradaPC[3]~input_o ));
// synopsys translate_off
defparam \entradaPC[3]~input .bus_hold = "false";
defparam \entradaPC[3]~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_lcell_comb \next_instruction~3 (
// Equation(s):
// \next_instruction~3_combout  = ( \entradaPC[3]~input_o  & ( !last_instruction[3] $ (((!\cont~0_combout  & (last_instruction[2] & \entradaPC[2]~input_o )) # (\cont~0_combout  & ((\entradaPC[2]~input_o ) # (last_instruction[2]))))) ) ) # ( 
// !\entradaPC[3]~input_o  & ( !last_instruction[3] $ (((!\cont~0_combout  & ((!last_instruction[2]) # (!\entradaPC[2]~input_o ))) # (\cont~0_combout  & (!last_instruction[2] & !\entradaPC[2]~input_o )))) ) )

	.dataa(!\cont~0_combout ),
	.datab(!last_instruction[2]),
	.datac(!\entradaPC[2]~input_o ),
	.datad(!last_instruction[3]),
	.datae(!\entradaPC[3]~input_o ),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\next_instruction~3_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \next_instruction~3 .extended_lut = "off";
defparam \next_instruction~3 .lut_mask = 64'h17E8E81717E8E817;
defparam \next_instruction~3 .shared_arith = "off";
// synopsys translate_on

dffeas \last_instruction[3] (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~3_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(last_instruction[3]),
	.prn(vcc));
// synopsys translate_off
defparam \last_instruction[3] .is_wysiwyg = "true";
defparam \last_instruction[3] .power_up = "low";
// synopsys translate_on

cyclonev_lcell_comb \cont~2 (
// Equation(s):
// \cont~2_combout  = ( \entradaPC[3]~input_o  & ( ((!\cont~0_combout  & (last_instruction[2] & \entradaPC[2]~input_o )) # (\cont~0_combout  & ((\entradaPC[2]~input_o ) # (last_instruction[2])))) # (last_instruction[3]) ) ) # ( !\entradaPC[3]~input_o  & ( 
// (last_instruction[3] & ((!\cont~0_combout  & (last_instruction[2] & \entradaPC[2]~input_o )) # (\cont~0_combout  & ((\entradaPC[2]~input_o ) # (last_instruction[2]))))) ) )

	.dataa(!\cont~0_combout ),
	.datab(!last_instruction[2]),
	.datac(!\entradaPC[2]~input_o ),
	.datad(!last_instruction[3]),
	.datae(!\entradaPC[3]~input_o ),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\cont~2_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \cont~2 .extended_lut = "off";
defparam \cont~2 .lut_mask = 64'h001717FF001717FF;
defparam \cont~2 .shared_arith = "off";
// synopsys translate_on

cyclonev_io_ibuf \entradaPC[4]~input (
	.i(entradaPC[4]),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\entradaPC[4]~input_o ));
// synopsys translate_off
defparam \entradaPC[4]~input .bus_hold = "false";
defparam \entradaPC[4]~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_lcell_comb \cont~1 (
// Equation(s):
// \cont~1_combout  = !last_instruction[4] $ (!\entradaPC[4]~input_o )

	.dataa(!last_instruction[4]),
	.datab(!\entradaPC[4]~input_o ),
	.datac(gnd),
	.datad(gnd),
	.datae(gnd),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\cont~1_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \cont~1 .extended_lut = "off";
defparam \cont~1 .lut_mask = 64'h6666666666666666;
defparam \cont~1 .shared_arith = "off";
// synopsys translate_on

cyclonev_lcell_comb \next_instruction~4 (
// Equation(s):
// \next_instruction~4_combout  = ( \entradaPC[3]~input_o  & ( \cont~1_combout  & ( (!last_instruction[3] & ((!\cont~0_combout  & ((!last_instruction[2]) # (!\entradaPC[2]~input_o ))) # (\cont~0_combout  & (!last_instruction[2] & !\entradaPC[2]~input_o )))) 
// ) ) ) # ( !\entradaPC[3]~input_o  & ( \cont~1_combout  & ( (!last_instruction[3]) # ((!\cont~0_combout  & ((!last_instruction[2]) # (!\entradaPC[2]~input_o ))) # (\cont~0_combout  & (!last_instruction[2] & !\entradaPC[2]~input_o ))) ) ) ) # ( 
// \entradaPC[3]~input_o  & ( !\cont~1_combout  & ( ((!\cont~0_combout  & (last_instruction[2] & \entradaPC[2]~input_o )) # (\cont~0_combout  & ((\entradaPC[2]~input_o ) # (last_instruction[2])))) # (last_instruction[3]) ) ) ) # ( !\entradaPC[3]~input_o  & ( 
// !\cont~1_combout  & ( (last_instruction[3] & ((!\cont~0_combout  & (last_instruction[2] & \entradaPC[2]~input_o )) # (\cont~0_combout  & ((\entradaPC[2]~input_o ) # (last_instruction[2]))))) ) ) )

	.dataa(!\cont~0_combout ),
	.datab(!last_instruction[2]),
	.datac(!\entradaPC[2]~input_o ),
	.datad(!last_instruction[3]),
	.datae(!\entradaPC[3]~input_o ),
	.dataf(!\cont~1_combout ),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\next_instruction~4_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \next_instruction~4 .extended_lut = "off";
defparam \next_instruction~4 .lut_mask = 64'h001717FFFFE8E800;
defparam \next_instruction~4 .shared_arith = "off";
// synopsys translate_on

dffeas \last_instruction[4] (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~4_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(last_instruction[4]),
	.prn(vcc));
// synopsys translate_off
defparam \last_instruction[4] .is_wysiwyg = "true";
defparam \last_instruction[4] .power_up = "low";
// synopsys translate_on

cyclonev_io_ibuf \entradaPC[5]~input (
	.i(entradaPC[5]),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\entradaPC[5]~input_o ));
// synopsys translate_off
defparam \entradaPC[5]~input .bus_hold = "false";
defparam \entradaPC[5]~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_lcell_comb \next_instruction~5 (
// Equation(s):
// \next_instruction~5_combout  = ( \entradaPC[5]~input_o  & ( !last_instruction[5] $ (((!\cont~2_combout  & (last_instruction[4] & \entradaPC[4]~input_o )) # (\cont~2_combout  & ((\entradaPC[4]~input_o ) # (last_instruction[4]))))) ) ) # ( 
// !\entradaPC[5]~input_o  & ( !last_instruction[5] $ (((!\cont~2_combout  & ((!last_instruction[4]) # (!\entradaPC[4]~input_o ))) # (\cont~2_combout  & (!last_instruction[4] & !\entradaPC[4]~input_o )))) ) )

	.dataa(!\cont~2_combout ),
	.datab(!last_instruction[4]),
	.datac(!\entradaPC[4]~input_o ),
	.datad(!last_instruction[5]),
	.datae(!\entradaPC[5]~input_o ),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\next_instruction~5_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \next_instruction~5 .extended_lut = "off";
defparam \next_instruction~5 .lut_mask = 64'h17E8E81717E8E817;
defparam \next_instruction~5 .shared_arith = "off";
// synopsys translate_on

dffeas \last_instruction[5] (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~5_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(last_instruction[5]),
	.prn(vcc));
// synopsys translate_off
defparam \last_instruction[5] .is_wysiwyg = "true";
defparam \last_instruction[5] .power_up = "low";
// synopsys translate_on

cyclonev_lcell_comb \cont~4 (
// Equation(s):
// \cont~4_combout  = ( \entradaPC[5]~input_o  & ( ((!\cont~2_combout  & (last_instruction[4] & \entradaPC[4]~input_o )) # (\cont~2_combout  & ((\entradaPC[4]~input_o ) # (last_instruction[4])))) # (last_instruction[5]) ) ) # ( !\entradaPC[5]~input_o  & ( 
// (last_instruction[5] & ((!\cont~2_combout  & (last_instruction[4] & \entradaPC[4]~input_o )) # (\cont~2_combout  & ((\entradaPC[4]~input_o ) # (last_instruction[4]))))) ) )

	.dataa(!\cont~2_combout ),
	.datab(!last_instruction[4]),
	.datac(!\entradaPC[4]~input_o ),
	.datad(!last_instruction[5]),
	.datae(!\entradaPC[5]~input_o ),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\cont~4_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \cont~4 .extended_lut = "off";
defparam \cont~4 .lut_mask = 64'h001717FF001717FF;
defparam \cont~4 .shared_arith = "off";
// synopsys translate_on

cyclonev_io_ibuf \entradaPC[6]~input (
	.i(entradaPC[6]),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\entradaPC[6]~input_o ));
// synopsys translate_off
defparam \entradaPC[6]~input .bus_hold = "false";
defparam \entradaPC[6]~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_lcell_comb \cont~3 (
// Equation(s):
// \cont~3_combout  = !last_instruction[6] $ (!\entradaPC[6]~input_o )

	.dataa(!last_instruction[6]),
	.datab(!\entradaPC[6]~input_o ),
	.datac(gnd),
	.datad(gnd),
	.datae(gnd),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\cont~3_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \cont~3 .extended_lut = "off";
defparam \cont~3 .lut_mask = 64'h6666666666666666;
defparam \cont~3 .shared_arith = "off";
// synopsys translate_on

cyclonev_lcell_comb \next_instruction~6 (
// Equation(s):
// \next_instruction~6_combout  = ( \entradaPC[5]~input_o  & ( \cont~3_combout  & ( (!last_instruction[5] & ((!\cont~2_combout  & ((!last_instruction[4]) # (!\entradaPC[4]~input_o ))) # (\cont~2_combout  & (!last_instruction[4] & !\entradaPC[4]~input_o )))) 
// ) ) ) # ( !\entradaPC[5]~input_o  & ( \cont~3_combout  & ( (!last_instruction[5]) # ((!\cont~2_combout  & ((!last_instruction[4]) # (!\entradaPC[4]~input_o ))) # (\cont~2_combout  & (!last_instruction[4] & !\entradaPC[4]~input_o ))) ) ) ) # ( 
// \entradaPC[5]~input_o  & ( !\cont~3_combout  & ( ((!\cont~2_combout  & (last_instruction[4] & \entradaPC[4]~input_o )) # (\cont~2_combout  & ((\entradaPC[4]~input_o ) # (last_instruction[4])))) # (last_instruction[5]) ) ) ) # ( !\entradaPC[5]~input_o  & ( 
// !\cont~3_combout  & ( (last_instruction[5] & ((!\cont~2_combout  & (last_instruction[4] & \entradaPC[4]~input_o )) # (\cont~2_combout  & ((\entradaPC[4]~input_o ) # (last_instruction[4]))))) ) ) )

	.dataa(!\cont~2_combout ),
	.datab(!last_instruction[4]),
	.datac(!\entradaPC[4]~input_o ),
	.datad(!last_instruction[5]),
	.datae(!\entradaPC[5]~input_o ),
	.dataf(!\cont~3_combout ),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\next_instruction~6_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \next_instruction~6 .extended_lut = "off";
defparam \next_instruction~6 .lut_mask = 64'h001717FFFFE8E800;
defparam \next_instruction~6 .shared_arith = "off";
// synopsys translate_on

dffeas \last_instruction[6] (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~6_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(last_instruction[6]),
	.prn(vcc));
// synopsys translate_off
defparam \last_instruction[6] .is_wysiwyg = "true";
defparam \last_instruction[6] .power_up = "low";
// synopsys translate_on

cyclonev_io_ibuf \entradaPC[7]~input (
	.i(entradaPC[7]),
	.ibar(gnd),
	.dynamicterminationcontrol(gnd),
	.o(\entradaPC[7]~input_o ));
// synopsys translate_off
defparam \entradaPC[7]~input .bus_hold = "false";
defparam \entradaPC[7]~input .simulate_z_as = "z";
// synopsys translate_on

cyclonev_lcell_comb \next_instruction~7 (
// Equation(s):
// \next_instruction~7_combout  = ( \entradaPC[7]~input_o  & ( !last_instruction[7] $ (((!\cont~4_combout  & (last_instruction[6] & \entradaPC[6]~input_o )) # (\cont~4_combout  & ((\entradaPC[6]~input_o ) # (last_instruction[6]))))) ) ) # ( 
// !\entradaPC[7]~input_o  & ( !last_instruction[7] $ (((!\cont~4_combout  & ((!last_instruction[6]) # (!\entradaPC[6]~input_o ))) # (\cont~4_combout  & (!last_instruction[6] & !\entradaPC[6]~input_o )))) ) )

	.dataa(!\cont~4_combout ),
	.datab(!last_instruction[6]),
	.datac(!\entradaPC[6]~input_o ),
	.datad(!last_instruction[7]),
	.datae(!\entradaPC[7]~input_o ),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\next_instruction~7_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \next_instruction~7 .extended_lut = "off";
defparam \next_instruction~7 .lut_mask = 64'h17E8E81717E8E817;
defparam \next_instruction~7 .shared_arith = "off";
// synopsys translate_on

dffeas \last_instruction[7] (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~7_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(last_instruction[7]),
	.prn(vcc));
// synopsys translate_off
defparam \last_instruction[7] .is_wysiwyg = "true";
defparam \last_instruction[7] .power_up = "low";
// synopsys translate_on

cyclonev_lcell_comb \cont~5 (
// Equation(s):
// \cont~5_combout  = ( \entradaPC[7]~input_o  & ( ((!\cont~4_combout  & (last_instruction[6] & \entradaPC[6]~input_o )) # (\cont~4_combout  & ((\entradaPC[6]~input_o ) # (last_instruction[6])))) # (last_instruction[7]) ) ) # ( !\entradaPC[7]~input_o  & ( 
// (last_instruction[7] & ((!\cont~4_combout  & (last_instruction[6] & \entradaPC[6]~input_o )) # (\cont~4_combout  & ((\entradaPC[6]~input_o ) # (last_instruction[6]))))) ) )

	.dataa(!\cont~4_combout ),
	.datab(!last_instruction[6]),
	.datac(!\entradaPC[6]~input_o ),
	.datad(!last_instruction[7]),
	.datae(!\entradaPC[7]~input_o ),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\cont~5_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \cont~5 .extended_lut = "off";
defparam \cont~5 .lut_mask = 64'h001717FF001717FF;
defparam \cont~5 .shared_arith = "off";
// synopsys translate_on

dffeas cont(
	.clk(\CLOCK~input_o ),
	.d(\cont~5_combout ),
	.asdata(vcc),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\habilitaPC~input_o ),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\cont~q ),
	.prn(vcc));
// synopsys translate_off
defparam cont.is_wysiwyg = "true";
defparam cont.power_up = "low";
// synopsys translate_on

cyclonev_lcell_comb \next_instruction~0 (
// Equation(s):
// \next_instruction~0_combout  = !last_instruction[0] $ (!\entradaPC[0]~input_o  $ (\cont~q ))

	.dataa(!last_instruction[0]),
	.datab(!\entradaPC[0]~input_o ),
	.datac(!\cont~q ),
	.datad(gnd),
	.datae(gnd),
	.dataf(gnd),
	.datag(gnd),
	.cin(gnd),
	.sharein(gnd),
	.combout(\next_instruction~0_combout ),
	.sumout(),
	.cout(),
	.shareout());
// synopsys translate_off
defparam \next_instruction~0 .extended_lut = "off";
defparam \next_instruction~0 .lut_mask = 64'h6969696969696969;
defparam \next_instruction~0 .shared_arith = "off";
// synopsys translate_on

dffeas \saidaPC[0]~reg0 (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~0_combout ),
	.asdata(\entradaPC[0]~input_o ),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(!\habilitaPC~input_o ),
	.ena(vcc),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\saidaPC[0]~reg0_q ),
	.prn(vcc));
// synopsys translate_off
defparam \saidaPC[0]~reg0 .is_wysiwyg = "true";
defparam \saidaPC[0]~reg0 .power_up = "low";
// synopsys translate_on

dffeas \saidaPC[1]~reg0 (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~1_combout ),
	.asdata(\entradaPC[1]~input_o ),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(!\habilitaPC~input_o ),
	.ena(vcc),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\saidaPC[1]~reg0_q ),
	.prn(vcc));
// synopsys translate_off
defparam \saidaPC[1]~reg0 .is_wysiwyg = "true";
defparam \saidaPC[1]~reg0 .power_up = "low";
// synopsys translate_on

dffeas \saidaPC[2]~reg0 (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~2_combout ),
	.asdata(\entradaPC[2]~input_o ),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(!\habilitaPC~input_o ),
	.ena(vcc),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\saidaPC[2]~reg0_q ),
	.prn(vcc));
// synopsys translate_off
defparam \saidaPC[2]~reg0 .is_wysiwyg = "true";
defparam \saidaPC[2]~reg0 .power_up = "low";
// synopsys translate_on

dffeas \saidaPC[3]~reg0 (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~3_combout ),
	.asdata(\entradaPC[3]~input_o ),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(!\habilitaPC~input_o ),
	.ena(vcc),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\saidaPC[3]~reg0_q ),
	.prn(vcc));
// synopsys translate_off
defparam \saidaPC[3]~reg0 .is_wysiwyg = "true";
defparam \saidaPC[3]~reg0 .power_up = "low";
// synopsys translate_on

dffeas \saidaPC[4]~reg0 (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~4_combout ),
	.asdata(\entradaPC[4]~input_o ),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(!\habilitaPC~input_o ),
	.ena(vcc),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\saidaPC[4]~reg0_q ),
	.prn(vcc));
// synopsys translate_off
defparam \saidaPC[4]~reg0 .is_wysiwyg = "true";
defparam \saidaPC[4]~reg0 .power_up = "low";
// synopsys translate_on

dffeas \saidaPC[5]~reg0 (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~5_combout ),
	.asdata(\entradaPC[5]~input_o ),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(!\habilitaPC~input_o ),
	.ena(vcc),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\saidaPC[5]~reg0_q ),
	.prn(vcc));
// synopsys translate_off
defparam \saidaPC[5]~reg0 .is_wysiwyg = "true";
defparam \saidaPC[5]~reg0 .power_up = "low";
// synopsys translate_on

dffeas \saidaPC[6]~reg0 (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~6_combout ),
	.asdata(\entradaPC[6]~input_o ),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(!\habilitaPC~input_o ),
	.ena(vcc),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\saidaPC[6]~reg0_q ),
	.prn(vcc));
// synopsys translate_off
defparam \saidaPC[6]~reg0 .is_wysiwyg = "true";
defparam \saidaPC[6]~reg0 .power_up = "low";
// synopsys translate_on

dffeas \saidaPC[7]~reg0 (
	.clk(\CLOCK~input_o ),
	.d(\next_instruction~7_combout ),
	.asdata(\entradaPC[7]~input_o ),
	.clrn(vcc),
	.aload(gnd),
	.sclr(gnd),
	.sload(!\habilitaPC~input_o ),
	.ena(vcc),
	.devclrn(devclrn),
	.devpor(devpor),
	.q(\saidaPC[7]~reg0_q ),
	.prn(vcc));
// synopsys translate_off
defparam \saidaPC[7]~reg0 .is_wysiwyg = "true";
defparam \saidaPC[7]~reg0 .power_up = "low";
// synopsys translate_on

assign saidaPC[0] = \saidaPC[0]~output_o ;

assign saidaPC[1] = \saidaPC[1]~output_o ;

assign saidaPC[2] = \saidaPC[2]~output_o ;

assign saidaPC[3] = \saidaPC[3]~output_o ;

assign saidaPC[4] = \saidaPC[4]~output_o ;

assign saidaPC[5] = \saidaPC[5]~output_o ;

assign saidaPC[6] = \saidaPC[6]~output_o ;

assign saidaPC[7] = \saidaPC[7]~output_o ;

endmodule
